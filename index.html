<!doctype html>
<html>
<head>
	<title>Tank game</title>
	<style>
		canvas {
			position: absolute;
			top: 5px;
			left: 5px;
		}
	</style>
</head>
<body>
<div id="form"
	 style="margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 200px; height: 100px; text-align: center;">
	<div>Username: <input id="username" autocomplete="off"/></div>
	<div>Choose a Color</div>
	<select id="colors">
		<option value="red">red</option>
		<option value="blue">blue</option>
		<option value="green">green</option>

	</select>
	<br/>
	<button style="margin: 0 auto;">Play!</button>
</div>
<canvas id="mazeCanvas" style="z-index: 0"></canvas>
<canvas id="tankCanvas" style="z-index: 1"></canvas>
<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
<script src="http://code.jquery.com/jquery-1.11.1.js"></script>
<script>
	//Basic variables defined
	var socket = io();
	var canvasWidth, canvasHeight;
	var mazeCanvas = document.getElementById('mazeCanvas');
	var tankCanvas = document.getElementById('tankCanvas');
	var mazeCtx = mazeCanvas.getContext('2d');
	var tankCtx = tankCanvas.getContext('2d');
	var isInit = false;

	//Submit username
	$("#form button").on('click', function () {
		$('#form').hide();
		isInit = true;
		socket.emit('addUser', $('#username').val(), $('#colors').val());
	});
	//Send key events to server
	addEventListener('keydown', function (e) {
		if (!isInit) {
			return;
		}
		switch (e.keyCode) {
			case 37:
			case 65:
				socket.emit('pressLeft');
				break;
			case 38:
			case 87:
				socket.emit('pressUp');
				break;
			case 39:
			case 68:
				socket.emit('pressRight');
				break;
			case 40:
			case 83:
				socket.emit('pressDown');
				break;
		}
	}, false);

	addEventListener('keyup', function (e) {
		if (!isInit) {
			return;
		}
		switch (e.keyCode) {
			case 37:
			case 65:
				socket.emit('releaseLeft');
				break;
			case 38:
			case 87:
				socket.emit('releaseUp');
				break;
			case 39:
			case 68:
				socket.emit('releaseRight');
				break;
			case 40:
			case 83:
				socket.emit('releaseDown');
				break;
		}
	}, false);

	socket.on('setCanvasSize', function (canvasSize) {
		canvasWidth = canvasSize[1];
		canvasHeight = canvasSize[0];
		mazeCanvas.width = canvasWidth;
		mazeCanvas.height = canvasHeight;
		tankCanvas.width = canvasWidth;
		tankCanvas.height = canvasHeight;
	});

	//Redraws the new tank positions
	socket.on('drawTanks', function (users) {
		if (!isInit) {
			return;
		}
		tankCtx.clearRect(0, 0, canvasWidth, canvasHeight);
		tankCtx.beginPath();
		for (var user in users) {
			if (users.hasOwnProperty(user)) {
				tankCtx.fillStyle = users[user].randColor;
				tankCtx.fillStyle = users[user].color;
				tankCtx.translate(users[user].x, users[user].y);
				tankCtx.rotate(users[user].angle);
				tankCtx.fillRect(-users[user].height / 2, -users[user].width / 2, users[user].height, users[user].width);
				//temp stuff for cannon
				tankCtx.fillStyle = 'black';
				tankCtx.fillRect(-users[user].height / 6, -users[user].width / 6, 5 * users[user].height / 6, users[user].width / 3);
				tankCtx.rotate(-users[user].angle);
				tankCtx.translate(-users[user].x, -users[user].y);
				tankCtx.fillStyle = 'black';
				tankCtx.font = '12px Arial';
				tankCtx.fillText(users[user].username, users[user].x, users[user].y + users[user].height / 2 + 3);
			}
		}
		tankCtx.closePath();
	});

	//Draws the maze
	socket.on('drawMaze', function (maze, rows, cols, wallWidth) {
		if (!isInit) {
			return;
		}
		var cellWidth = (canvasWidth - (cols + 1) * wallWidth) / cols;
		var cellHeight = (canvasHeight - (rows + 1) * wallWidth) / rows;
		mazeCtx.beginPath();
		for (var i = 0; i < rows; i++) {
			for (var j = 0; j < cols; j++) {
				if (maze[i][j].left && j == 0) {
					mazeCtx.rect(j * (cellWidth + wallWidth), i * (cellHeight + wallWidth), wallWidth, cellHeight + 2 * wallWidth);
				}
				if (maze[i][j].right) {
					mazeCtx.rect((j + 1) * (cellWidth + wallWidth), i * (cellHeight + wallWidth), wallWidth, cellHeight + 2 * wallWidth);
				}
				if (maze[i][j].top && i == 0) {
					mazeCtx.rect(j * (cellWidth + wallWidth), i * (cellHeight + wallWidth), cellWidth + 2 * wallWidth, wallWidth);
				}
				if (maze[i][j].bottom) {
					mazeCtx.rect(j * (cellWidth + wallWidth), (i + 1) * (cellHeight + wallWidth), cellWidth + 2 * wallWidth, wallWidth);
				}
			}
		}
		mazeCtx.fill();
		mazeCtx.closePath();
	});
</script>
</body>
</html>
